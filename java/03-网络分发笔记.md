# 网络分发

请求 从 客户端出来之后的优化。

## DNS

目的：将域名解析成IP地址。

理解成：web服务，挂着一个 分布式数据库，并且提供了 crud功能。

记录类型：

A（Address）：域名和IP的对应关系。

CName（Canonical Name）：域名和域名的对应关系。

NS（name server）：域名和   能解析此域名的域名服务器 的对应关系。

## 服务器类型

根域名服务器：13个。

A：主根，其他：辅根。2020年8月统计：1097个根域名服务器。

根服务器的镜像服务器：

## 域名解析流程

教科书：

LDNS。www.baidu.com

缓存

xxx.a.baidu.com  hosts

浏览器

操作系统：hosts

LDNS:

a.baidu.com  ns服务器

回答问题：

域名和域名的对应关系怎么理解？

xiaodoufu.com    zhangdou.com

优化：

1。提前做好dns缓存。

2。A 记录，域名 对应 多个 Ip？结论：通过dns做负载均衡。

缺点：时效性问题。负载均衡算法 无法灵活使用。

---

## CDN

结论：大型系统，部署多个节点。

请求多个节点如何做优化：

1。将请求分配到多个节点上，减少每个节点的并发数。

2。将请求落到离用户最近（地理位置最近，网络拓扑最近）的节点上。

cdn：放静态资源。

cdn两个关键节点：

源站：核心业务系统，所有信息的源头。

缓存（边缘）节点：静态资源。

![image.png](https://fynotefile.oss-cn-zhangjiakou.aliyuncs.com/fynote/30/1643030778000/e9049a6311e44a64995c08eafa97275c.png)

流程：画图。

节点数目：

### 设计CDN

用户来源（如何识别，根据ip地址查询用户 地理信息）

就近分发（）

1。www.mashibing.com:   cname  www.mashibing.com---xiaodoufu.com

if(地理信息 是否 是 北京的){

指向  北京

}else{

指向 杭州。

}

内容的缓存：

/xxx.html    /xxx.png   静态  缓存到 cdn中。

做好映射：/xxx.html   value：响应的值。

扩展：

数据来源：

1。启动时，初始化。内置好。

2。增量更新。有效期。

# CDN总结

流程图OK

扩展一下（类似于：注册中心）：

地址的获取：

内容的请求：

# 多地址直连

功能：将用户动态的请求 做分发。

用户、调用方。

cdn服务商，管理服务的通讯录。维护用户的cdn节点（源站 ：提供动态内容）的列表。

cdn节点（真正提供服务的节点）。

方案：

注册中心：优化：客户端缓存。

规则中心

更简化的方法：将选择权 交个用户。

# 代理

请求到了确定的IP。IP不一定是真正提供服务的机器，只是他们对外提供的统一的IP。

正向代理

反向代理

识别用户的请求：

应用层 http ftp

表示层

会话层

传输层 tcp

网络层

数据链路层

物理层

4层反向代理：根据用户的ip和端口。

7层反向代理：根据用户协议，方法，头，正文参数，cookie。掌握更多的内容，更智能，效率低。

upstream：

access_by_lua_file.

# 负载均衡算法

轮询：RR。Round Robin。挨个发。适用于所有服务器硬件都相同的场景。一个一个来，

代码实现：

加权：WRR。Weight round robin。

代码实现：比如两个服务，一个权重是6 ，另一个权重是4。

1-10之间去 随机数。如果取到  1-6，那么 找6权重的服务。

如果取到 7-10，找 4权重的服务。

# 随机

random。

# hash（原地址散列） Source Hashing

请求来的Ip  是  a， 我将a进行hash    ，做成 对应到  1好 服务节点。

好处：便于session维护。

hash

# 最少链接 Least connecitons

将请求路由到 最少链接的服务器上。

代码实现：

redis存储结构：hash。 hset  key field value

# 服务集群方案

## 并发和并行

并行：在某个时间点，多个任务进行。

并发：在某个时间点，只有一个任务进行。但是 在一个时间段，有多个任务同时进行。

集群。

集群缺点：

注意幂等。（幂等：每次操作都是一样的结果）

注意数据存储的共享。

杨通

弄一个数据共享的模块？

瞿菲

分布式事务吧

## 无状态节点集群

做集群的时候，不要修改服务内存的数据。

无状态：请求到达服务器，携带了服务端所需要的所有参数，服务端（服务的内存）不存储

所有跟请求相关的任何数据。map

有状态：在服务端存储之前的请求信息，用于后面请求的处理。

集群一般用无状态。确保无状态，必须保证所有接口都是恒等类，系统内存中存储的数据不能发生变化。可以

考虑通过 公共存储，实现无状态。

协作的问题：

定时任务，发短信。

**锁**：在程序执行的时候判断是否可以发？

**外部唤醒**：

内部和外部。

## 单一服务节点集群

选服？实时对战。长连接。

关键：实现用户和服务器对应关系的映射。

手动选择服务器

用户id分配服务器

解决了有状态的问题。

容错性差。

## 信息共享节点集群

多个服务共同连接：共享的存储。

协作：

缺点：受到共享存储的限制。存储容量，读写性能。故障的单点，瓶颈所在。

## 信息一致节点集群

读写分离。

分流。

存储之间：数据一致性问题。

强一致：

弱一致：最终一致

## 分布式系统

统一接口的定义。彼此当成黑盒。

微服务

总结：

一个服务---服务的分身（复制多份）----垂直切分。

---

如何实现的高并发：

高并发系统中的代码，就是我们普通的代码。

if else for

大量的机器，架构设计。

项目上线----加机器------优化架构------沉淀技术（中间件）----

课程后面加代码实践。

# CAP

一致性。

越往上发展，设计和理论越显得重要。

是理解分布式系统的起点。

C 一致性，A 可用性，P 分区容错性，不可能同时满足，**三者中选二挑一**。

数据的一致性，从什么角度去看？

读、写。

P：分区容错性。

分区：

容错：

形成分区的原因只有网络故障这一种吗

网络的8大谬误：

1 网络总是可靠的：

2 没有延迟。

3 带宽无限

4 网络总是安全的。

5 网络拓扑不会改变。

6 只有一个管理员

7 传输代价为0：

8 网络是同构的。

P 必须保证。即使网络出现问题，我们的系统也要能正常使用。

**三选二挑一**。

P  CA。

那P可以通过哪些方式保证呢？

数据被复制到其他节点上。提前把数据给你。mysql，redis：slaveOf ，zk。

为什么只能选 AP，CP？

一致性：写什么，就能读出什么。写：原子操作。

强一致性：写操作完成，后续的所有的读都能看到新数据。

弱一致性：写操作后，对该数据的读，可能是新值，也可能是旧值。

**最终一致性**：写后，读在一段时间内，可能读的是旧值，但是 最终，能读到新值。

可用性：向未崩溃的节点发请求，总能收到响应。有数据就行，管它对不对。

如何取舍？

看业务要求，或者说容忍度。

（中间件去聊）

AP：web缓存，dns，cdn。（大部分情况下）

**不错的策略**：

保证可用性和分区容错性，保证AP，兼顾C一致性（舍弃强一致性，保证最终一致性）。

电商：买东西 送积分。先买东西，积分次日到账。

红包，

如果保证强一致性，会对吞吐量造成负面影响。

A、B两系统，合起来完成一个业务。

A用10s，B用10s。一共 20s。10s。解耦。

信息一致性方案：

前面所有内容：服务和服务之间的并发。

# 服务内的并发

## 多进程

每个进程之间，资源独立，具有很强的隔离性。

java -jar xxxx.jar:    启动一个java进程。

两台物理机：a、b、c三个服务。

## 多线程

一个方法：先计算，然后 等待io，

出租车  计费：

时长计费（1min 多少钱），里程计费（1公里  多少钱）。

future。

目的：

1 提高效率。

2 实现异步。提前释放主线程。（降低了响应时间，节省了保持客户端和服务连接的资源）

## 线程数的计算

公式一：线程数=cpu核数  *  cpu利用率  * (1+w/c)。

cpu利用率：0-1之间。

双核：0.4s, 0.6,    = 50%。

算的时候，用100%。

线程数=cpu核数   * (1+w/c)。

w：等待时间，c：计算时间。wait/computer

2c  cpu  2ms,  1ms  ==    2*(1+2)=6 个线程。

直观的结论：等待越久，线程数越高。

wc：

公式二：

线程数=cpu核数/(1-阻塞系数)。

阻塞系数：计算密集型：0，IO密集型：1。

统一公式：

cpu核数   * (1+w/c)=cpu核数/(1-阻塞系数)

阻塞系数= w/w+c。

实际以压测为准。

线程数，qps，机器配置。

cpu核数   * (1+w/c)

IO密集型和计算密集型的计算方式不一样吧老师

2 cpu核数。

计算密集型： cpu核数

**压测为准。**
